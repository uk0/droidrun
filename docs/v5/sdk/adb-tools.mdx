---
title: AndroidDriver
---

Raw Android device I/O via ADB + Portal.

<a id="droidrun.tools.driver.android.AndroidDriver"></a>

## AndroidDriver

```python
class AndroidDriver(DeviceDriver)
```

Raw Android device I/O via ADB and the Droidrun Portal app.

AndroidDriver provides low-level device communication for Android devices through ADB (Android Debug Bridge). It supports both TCP communication and content provider modes via the Droidrun Portal app. AndroidDriver declares its capabilities in the `supported` set, and unsupported methods raise `NotImplementedError`.

<a id="droidrun.tools.driver.android.AndroidDriver.__init__"></a>

#### AndroidDriver.\_\_init\_\_

```python
def __init__(
    serial: str | None = None,
    use_tcp: bool = False,
    remote_tcp_port: int = 8080,
) -> None
```

Initialize the AndroidDriver instance.

**Arguments**:

- `serial` _str | None_ - Device serial number (e.g., "emulator-5554", "192.168.1.100:5555"). If None, auto-detects the first available device.
- `use_tcp` _bool_ - Whether to prefer TCP communication (default: False). TCP is faster but requires port forwarding. Falls back to content provider mode if TCP fails.
- `remote_tcp_port` _int_ - TCP port for Portal app communication on device (default: 8080)

**Usage:**

```python
from droidrun.tools import AndroidDriver

# Auto-detect device
driver = AndroidDriver()

# Specific device
driver = AndroidDriver(serial="emulator-5554")

# TCP mode (faster communication, requires port forwarding)
driver = AndroidDriver(serial="emulator-5554", use_tcp=True)
```

**Supported methods:**

```python
AndroidDriver.supported = {
    "tap", "swipe", "input_text", "press_key", "drag",
    "start_app", "install_app", "screenshot",
    "get_ui_tree", "get_date", "get_apps", "list_packages",
}
```

**Notes:**
- Automatically sets up the Droidrun Portal keyboard on `connect()` via `setup_keyboard()`
- Creates a PortalClient instance that handles TCP/content provider communication
- Device serial can be emulator name, USB serial, or TCP/IP address:port
- Must call `connect()` or `ensure_connected()` before using any methods

---

## Lifecycle Methods

<a id="droidrun.tools.driver.android.AndroidDriver.connect"></a>

#### AndroidDriver.connect

```python
async def connect() -> None
```

Establish connection to the device. Discovers the ADB device, creates a PortalClient, and sets up the Portal keyboard.

**Usage:**

```python
driver = AndroidDriver(serial="emulator-5554")
await driver.connect()
```

<a id="droidrun.tools.driver.android.AndroidDriver.ensure_connected"></a>

#### AndroidDriver.ensure\_connected

```python
async def ensure_connected() -> None
```

Connect if not already connected. Safe to call multiple times.

---

## Input Action Methods

<a id="droidrun.tools.driver.android.AndroidDriver.tap"></a>

#### AndroidDriver.tap

```python
async def tap(x: int, y: int) -> None
```

Tap at absolute pixel coordinates on the device screen.

**Arguments**:

- `x` _int_ - X coordinate
- `y` _int_ - Y coordinate

**Usage:**

```python
await driver.tap(540, 960)
```

<a id="droidrun.tools.driver.android.AndroidDriver.swipe"></a>

#### AndroidDriver.swipe

```python
async def swipe(
    x1: int,
    y1: int,
    x2: int,
    y2: int,
    duration_ms: float = 1000,
) -> None
```

Swipe from (x1, y1) to (x2, y2).

**Arguments**:

- `x1` _int_ - Starting X coordinate
- `y1` _int_ - Starting Y coordinate
- `x2` _int_ - Ending X coordinate
- `y2` _int_ - Ending Y coordinate
- `duration_ms` _float_ - Duration of swipe in milliseconds (default: 1000)

**Usage:**

```python
# Swipe up (scroll down content)
await driver.swipe(540, 1500, 540, 500, duration_ms=300)

# Swipe left
await driver.swipe(800, 960, 200, 960, duration_ms=250)
```

**Notes:**
- Duration is converted to seconds internally (dividing by 1000)
- Includes an async sleep matching the swipe duration for UI settling

<a id="droidrun.tools.driver.android.AndroidDriver.input_text"></a>

#### AndroidDriver.input\_text

```python
async def input_text(text: str, clear: bool = False) -> bool
```

Type text into the currently focused field.

**Arguments**:

- `text` _str_ - Text to input. Supports Unicode and special characters.
- `clear` _bool_ - Whether to clear existing text before inputting (default: False)

**Returns**:

- `bool` - True if input succeeded, False otherwise

**Usage:**

```python
await driver.tap(540, 300)  # Focus text field first
success = await driver.input_text("Hello World")

# Clear existing text and input new text
success = await driver.input_text("New text", clear=True)
```

**Notes:**
- Uses the Droidrun Portal app keyboard for reliable text input via PortalClient
- Supports Unicode characters and special characters

<a id="droidrun.tools.driver.android.AndroidDriver.press_key"></a>

#### AndroidDriver.press\_key

```python
async def press_key(keycode: int) -> None
```

Send a single key-event to the device.

**Common keycodes:**
- `3`: HOME
- `4`: BACK
- `66`: ENTER
- `67`: DELETE

Full keycode reference: [Android KeyEvent Documentation](https://developer.android.com/reference/android/view/KeyEvent)

**Arguments**:

- `keycode` _int_ - Android keycode to press

**Usage:**

```python
await driver.press_key(66)  # Press enter
await driver.press_key(3)   # Press home
await driver.press_key(4)   # Press back
```

<a id="droidrun.tools.driver.android.AndroidDriver.drag"></a>

#### AndroidDriver.drag

```python
async def drag(
    x1: int,
    y1: int,
    x2: int,
    y2: int,
    duration: float = 3.0,
) -> None
```

Drag from (x1, y1) to (x2, y2).

**Arguments**:

- `x1` _int_ - Starting X coordinate
- `y1` _int_ - Starting Y coordinate
- `x2` _int_ - Ending X coordinate
- `y2` _int_ - Ending Y coordinate
- `duration` _float_ - Duration of drag in seconds (default: 3.0)

**Notes:**
- Currently raises `NotImplementedError` (declared in `supported` set but not yet implemented)

---

## App Management Methods

<a id="droidrun.tools.driver.android.AndroidDriver.start_app"></a>

#### AndroidDriver.start\_app

```python
async def start_app(package: str, activity: str | None = None) -> str
```

Launch an application on the device.

If activity is not provided, automatically resolves the main/launcher activity using `cmd package resolve-activity`.

**Arguments**:

- `package` _str_ - Package name (e.g., "com.android.settings", "com.google.android.apps.messaging")
- `activity` _str | None_ - Optional activity name (e.g., ".Settings"). If None, auto-detects the main launcher activity.

**Returns**:

- `str` - Result message indicating success or error

**Usage:**

```python
# Auto-detect main activity
result = await driver.start_app("com.android.settings")

# Specific activity
result = await driver.start_app("com.android.settings", ".Settings")
```

<a id="droidrun.tools.driver.android.AndroidDriver.install_app"></a>

#### AndroidDriver.install\_app

```python
async def install_app(path: str, **kwargs) -> str
```

Install an APK on the device.

**Arguments**:

- `path` _str_ - Path to the APK file on the local machine
- `reinstall` _bool_ - Whether to reinstall if app already exists (default: False)
- `grant_permissions` _bool_ - Whether to grant all permissions automatically (default: True)

**Returns**:

- `str` - Result message indicating success or error

**Usage:**

```python
result = await driver.install_app("/path/to/app.apk")
result = await driver.install_app("/path/to/app.apk", reinstall=True)
```

<a id="droidrun.tools.driver.android.AndroidDriver.list_packages"></a>

#### AndroidDriver.list\_packages

```python
async def list_packages(include_system: bool = False) -> List[str]
```

Return installed package names.

**Arguments**:

- `include_system` _bool_ - Whether to include system apps (default: False)

**Returns**:

- `List[str]` - List of package names

<a id="droidrun.tools.driver.android.AndroidDriver.get_apps"></a>

#### AndroidDriver.get\_apps

```python
async def get_apps(include_system: bool = True) -> List[Dict[str, str]]
```

Return installed apps as list of dicts with 'package' and 'label' keys.

**Arguments**:

- `include_system` _bool_ - Whether to include system apps (default: True)

**Returns**:

- `List[Dict[str, str]]` - List of dictionaries containing 'package' and 'label' keys

---

## State and Observation Methods

<a id="droidrun.tools.driver.android.AndroidDriver.screenshot"></a>

#### AndroidDriver.screenshot

```python
async def screenshot(hide_overlay: bool = True) -> bytes
```

Capture the current screen as raw PNG bytes.

**Arguments**:

- `hide_overlay` _bool_ - Whether to hide Portal app overlay elements during screenshot (default: True)

**Returns**:

- `bytes` - Raw PNG image data

**Usage:**

```python
png_bytes = await driver.screenshot()
with open("screenshot.png", "wb") as f:
    f.write(png_bytes)
```

<a id="droidrun.tools.driver.android.AndroidDriver.get_ui_tree"></a>

#### AndroidDriver.get\_ui\_tree

```python
async def get_ui_tree() -> Dict[str, Any]
```

Return the raw UI / accessibility tree from the device.

Returns a dictionary containing both the accessibility tree and phone state data from the Portal app.

**Returns**:

- `Dict[str, Any]` - Raw UI tree data from the device

<a id="droidrun.tools.driver.android.AndroidDriver.get_date"></a>

#### AndroidDriver.get\_date

```python
async def get_date() -> str
```

Get the current date and time on the device.

**Returns**:

- `str` - Date and time string from device

**Usage:**

```python
date = await driver.get_date()
print(f"Device date: {date}")
# Output: "Thu Jan 16 14:30:25 UTC 2025"
```

---

## Properties

**Instance variables:**

- `device` - ADB device instance (from async_adbutils)
- `portal` - PortalClient instance for device communication (TCP or content provider mode)
- `supported` - Set of supported method names for capability checking

---

## Notes

- **Portal app required**: The Droidrun Portal app must be installed and accessibility service enabled on the device
- **TCP vs Content Provider**: TCP is faster but requires port forwarding (`adb forward tcp:8080 tcp:8080`). Content provider is the fallback mode using ADB shell commands.
- **Capability checking**: Check `"method_name" in driver.supported` to determine if a method is available before calling it
- **Async-only**: All methods are async and must be awaited
- **No element resolution**: AndroidDriver provides raw device I/O only. Element resolution (by index) is handled by `UIState` via the `StateProvider` layer.

---

## Example Workflow

```python
import asyncio
from droidrun.tools import AndroidDriver

async def main():
    # Initialize driver
    driver = AndroidDriver(serial="emulator-5554", use_tcp=True)
    await driver.connect()

    # Start Chrome app
    result = await driver.start_app("com.android.chrome")
    print(result)

    # Get UI tree (raw data)
    tree = await driver.get_ui_tree()

    # Tap at coordinates
    await driver.tap(540, 300)

    # Input text
    await driver.input_text("Droidrun framework")

    # Press enter
    await driver.press_key(66)

    # Take screenshot
    png_bytes = await driver.screenshot()
    with open("search_result.png", "wb") as f:
        f.write(png_bytes)

asyncio.run(main())
```

**Note:** For higher-level interactions with element indexing and structured results, use action functions with `ActionContext` (see [DroidAgent](/v5/sdk/droid-agent)) rather than calling the driver directly.
